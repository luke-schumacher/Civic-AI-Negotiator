<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civic Policy AI Interaction Study</title>
    <link rel="icon" href="assets/logo.svg" type="image/svg+xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- This allows the Groq SDK to run in a browser environment -->

    
    <style>
        :root {
            /* Professional, clean color palette */
            --bg-color: #f8f9fa;
            --text-color: #1a1a1a;
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --secondary-color: #f1f5f9;
            --border-color: #e2e8f0;
            --container-bg: #ffffff;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 6px rgba(0,0,0,0.07);
            --green-btn: #10b981;
            --green-btn-hover: #059669;

            /* Agent colors - professional and distinct */
            --agent-for-bg: #f0fdf4;
            --agent-for-border: #16a34a;
            --agent-for-accent: #dcfce7;
            --agent-against-bg: #fef2f2;
            --agent-against-border: #dc2626;
            --agent-against-accent: #fee2e2;
            --neutral-bg: #eff6ff;
            --neutral-border: #3b82f6;
        }

        /* Responsive base font size */
        html { font-size: 100%; }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
            padding: 2rem 1rem;
            box-sizing: border-box;
        }

        #app-container {
            width: 100%;
            max-width: 1400px;
            min-height: 90vh;
            background: var(--container-bg);
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%);
            color: white;
            padding: 1.75rem 2rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* ASSET: Header Logo */
        .logo-placeholder {
            width: 40px; 
            height: 40px;
            /* ASSET: Path: 'assets/logo.svg' */
            background: url('assets/logo.svg') no-repeat center center;
            background-size: contain;
            /* Fallback color if logo fails */
            background-color: rgba(255,255,255,0.2);
            border-radius: 8px;
        }
        
        header h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .screen { display: none; }
        .screen.active {
            display: flex;
            flex-direction: column;
            padding: 3rem;
            gap: 2rem;
            flex-grow: 1;
            background: var(--bg-color);
        }

        h2 {
            color: var(--text-color);
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: -0.03em;
        }

        h3 {
            color: var(--text-color);
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 0.75rem;
        }

        p, li {
            line-height: 1.7;
            font-size: 1rem;
            color: #4b5563;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: 'Inter', sans-serif;
            box-shadow: var(--shadow);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        button:hover {
            background-color: var(--primary-hover);
            box-shadow: var(--shadow-lg);
            transform: translateY(-1px);
        }
        button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
            opacity: 0.6;
        }
        
        /* Welcome Screen Button Group */
        .welcome-button-group {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 2rem;
        }
        .welcome-button-group button {
            background-color: white;
            color: var(--text-color);
            text-align: left;
            border: 2px solid var(--border-color);
            flex: 1;
            max-width: 350px;
            display: flex;
            align-items: center;
            padding: 2rem 1.5rem;
            transition: all 0.2s ease;
            box-shadow: var(--shadow);
        }
        .welcome-button-group button:hover {
            background-color: white;
            border-color: var(--primary-color);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        .welcome-button-group button div {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-color);
        }
        .welcome-button-group button span {
            font-weight: 500;
            font-size: 0.9rem;
            color: #6b7280;
        }
        
        /* ASSET: Button Icons */
        .button-icon {
            width: 48px;
            height: 48px;
            margin-right: 1.5rem;
            background-color: var(--secondary-color);
            border-radius: 8px;
            padding: 8px;
            object-fit: contain;
        }

        /* Problem Selection Buttons */
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .button-group button {
            background-color: white;
            color: var(--text-color);
            text-align: left;
            border: 2px solid var(--border-color);
            padding: 1rem 1.5rem;
            font-size: 1rem;
        }
        .button-group button:hover {
            background-color: white;
            border-color: var(--primary-color);
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        /* UPDATED: Layout Fix */
        #interaction-screen {
            flex-direction: row;
            gap: 2rem;
            flex-grow: 1; /* This makes the screen fill its parent */
            overflow: hidden; /* Prevent child overflow */
        }

        #main-interaction, #clarification-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            background: white;
            height: 100%;
            box-sizing: border-box;
            box-shadow: var(--shadow);
        }

        /* Give more space to negotiation panel */
        #main-interaction { flex: 2; }
        #clarification-panel { flex: 1; }
        #single-chatbot-view { width: 100%; }

        /* UPDATED: This container now fills height */
        #single-chatbot-view, #dual-negotiation-view {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Chat window styling */
        .chat-window {
            flex-grow: 1;
            min-height: 300px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-color);
            padding: 1.25rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .chat-message {
            padding: 0.875rem 1.25rem;
            border-radius: 10px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 0.95rem;
        }
        .chat-message.user {
            background: var(--primary-color);
            color: white;
            align-self: flex-end;
            border-radius: 12px 12px 2px 12px;
            box-shadow: var(--shadow);
        }
        .chat-message.assistant {
            background: white;
            color: var(--text-color);
            align-self: flex-start;
            border-radius: 12px 12px 12px 2px;
            border: 2px solid var(--border-color);
            position: relative;
            padding-left: 60px;
            min-height: 40px;
        }
        
        /* UPDATED: Avatar styling */
        .chat-message.assistant::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 10px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ccc; /* Fallback */
            /* FIX: Use contain for SVGs */
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* ASSET: Neutral Avatar */
        .chat-message.assistant.avatar-neutral::before {
            /* FIX: Path: 'assets/avatar-neutral.svg' */
            background-image: url('assets/avatar-neutral.svg');
        }
        /* ASSET: Agent For Avatar */
        .chat-message.agent-for::before {
            background-image: url('assets/avatar-alpha.svg');
        }
        /* ASSET: Agent Against Avatar */
        .chat-message.agent-against::before {
            background-image: url('assets/avatar-beta.svg');
        }
        /* ASSET: Fact Checker Avatar */
        .chat-message.fact-checker::before {
            background-image: url('assets/avatar-neutral.svg');
        }
        
        /* NEW: "Thinking" message styling */
        .chat-message.thinking {
            font-style: italic;
            color: #555;
        }
        /* "Thinking" dots animation */
        .chat-message.thinking::after {
            content: '.';
            animation: dots 1s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: "."; }
            40% { content: ".."; }
            60%, 80%, 100% { content: "..."; }
        }

        .chat-message strong {
            display: block;
            margin-bottom: 0.25rem;
            font-family: 'Roboto Mono', monospace;
            color: var(--primary-color);
            font-size: 0.9rem;
        }
        .chat-message.assistant strong { color: #555; }
        
        /* System message styling */
        .chat-message.system {
            background: var(--secondary-color);
            color: #64748b;
            border: 1px solid var(--border-color);
            align-self: center;
            font-size: 0.875rem;
            width: 100%;
            max-width: 100%;
            text-align: center;
            box-sizing: border-box;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-weight: 500;
        }

        .chat-input {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .chat-input input {
            flex-grow: 1;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
            transition: all 0.15s ease;
        }
        .chat-input input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        #stance-submission-screen textarea {
            width: 100%;
            height: 250px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
            resize: vertical;
            box-sizing: border-box;
            transition: all 0.15s ease;
            line-height: 1.6;
        }
        #stance-submission-screen textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        /* Agent-specific colors */
        #dual-negotiation-view .chat-message.agent-for {
            background: var(--agent-for-bg);
            border: 2px solid var(--agent-for-border);
            border-left-width: 4px;
        }
        #dual-negotiation-view .chat-message.agent-against {
            background: var(--agent-against-bg);
            border: 2px solid var(--agent-against-border);
            border-left-width: 4px;
        }
        #dual-negotiation-view .chat-message.agent-for strong {
            color: var(--agent-for-border);
            font-weight: 700;
        }
        #dual-negotiation-view .chat-message.agent-against strong {
            color: var(--agent-against-border);
            font-weight: 700;
        }
        #dual-negotiation-view .chat-message.fact-checker {
            background: var(--neutral-bg);
            border: 2px solid var(--neutral-border);
            border-left-width: 4px;
            font-size: 0.9rem;
        }
        #dual-negotiation-view .chat-message.fact-checker strong {
            color: var(--neutral-border);
            font-weight: 700;
        }
        
        /* Proceed Button Styling */
        .proceed-btn {
            background-color: var(--green-btn);
            width: 100%;
            margin-top: 1rem;
            padding: 1rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
        }
        .proceed-btn:hover {
            background-color: var(--green-btn-hover);
        }
        .proceed-btn:disabled {
            background-color: #9ca3af;
            box-shadow: none;
            transform: none;
            opacity: 0.6;
        }
        
        /* NEW: Final Screen Styling */
        #complete-screen {
            text-align: center;
            justify-content: center;
            align-items: center;
        }
        .complete-icon {
            width: 60px;
            height: 60px;
            /* ASSET: Path: 'assets/icon-complete.svg' */
            background: url('assets/icon-complete.svg') no-repeat center center;
            background-size: contain;
            background-color: #e6fff0;
            border-radius: 50%;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        /* Loading spinner */
        .spinner {
            width: 1.25em;
            height: 1.25em;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* TLDR Section */
        .tldr-section {
            background: linear-gradient(135deg, #eff6ff 0%, #e0f2fe 100%);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.25rem 0;
            box-shadow: var(--shadow);
        }
        .tldr-section h3 {
            margin: 0 0 1rem 0;
            color: var(--primary-color);
            font-size: 1.2rem;
            font-weight: 700;
        }
        .tldr-section ul {
            margin: 0;
            padding-left: 1.5rem;
            line-height: 1.8;
        }
        .tldr-section li {
            margin-bottom: 0.75rem;
            color: var(--text-color);
        }

        /* Back button styling */
        .back-btn {
            background-color: #64748b;
            margin-bottom: 1.5rem;
            padding: 0.65rem 1.25rem;
            font-size: 0.9rem;
            align-self: flex-start;
            font-weight: 500;
        }
        .back-btn:hover {
            background-color: #475569;
        }

    </style>
</head>
<body>

    <div id="app-container">
        <header>
            <!-- ASSET: Header Logo -->
            <div class="logo-placeholder"></div>
            <h1>Civic Policy AI Interaction Study</h1>
        </header>

        <!-- Screen 1: Welcome & Group Assignment -->
        <div class="screen active" id="welcome-screen">
            <h2>Welcome, Participant</h2>
            <p>Thank you for participating in this research study on AI-assisted decision-making. Your task will be to review a complex policy topic, use an AI tool to understand it, and then provide your stance on the matter.</p>
            <p>Please select your assigned group to begin.</p>
            <!-- UPDATED: Button layout and icons -->
            <div class="welcome-button-group">
                <button onclick="app.startSession('singleChatbot')">
                    <!-- ASSET: Path: 'assets/icon-single-chat.svg' -->
                    <img src="assets/icon-single-chat.svg" alt="" class="button-icon" 
                         onerror="this.style.display='none'">
                    <div>Start as Group 1<br><span>(Single Chatbot)</span></div>
                </button>
                <button onclick="app.startSession('dualNegotiation')">
                    <!-- ASSET: Path: 'assets/icon-dual-chat.svg' -->
                    <img src="assets/icon-dual-chat.svg" alt="" class="button-icon"
                         onerror="this.style.display='none'">
                    <div>Start as Group 2<br><span>(Dual-AI Negotiation)</span></div>
                </button>
            </div>
        </div>

        <!-- Screen 2: Problem Selection -->
        <div class="screen" id="problem-selection-screen">
            <button class="back-btn" onclick="app.goBack()">← Back</button>
            <h2>Step 1: Select a Policy Topic</h2>
            <p>Choose a topic to explore, or define your own below.</p>
            <div class="button-group" id="problem-list">
                <!-- Problems will be dynamically inserted here -->
            </div>
            <div style="margin-top: 2rem;">
                <h3 style="font-size: 1.1rem; margin-bottom: 0.5rem;">Or define your own topic:</h3>
                <input type="text" id="custom-topic-title" placeholder="Topic title (e.g., Universal Basic Income)" style="width: 100%; padding: 0.75rem; margin-bottom: 0.5rem; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem;">
                <textarea id="custom-topic-description" placeholder="Brief description of the topic and key points of debate..." style="width: 100%; height: 100px; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem; resize: vertical;"></textarea>
                <button onclick="app.selectCustomTopic()" style="margin-top: 0.5rem;">Use Custom Topic</button>
            </div>
        </div>

        <!-- Screen 3: Interaction -->
        <div class="screen" id="interaction-screen">
            <!-- This panel is for Group 1 (Main) and Group 2 (Main) -->
            <div id="main-interaction">
                <!-- Group 1: Single Chatbot View -->
                <div id="single-chatbot-view" style="display: none;">
                    <button class="back-btn" onclick="app.goBack()">← Back</button>
                    <h2>Step 2: Explore the Topic</h2>
                    <p>Ask questions to understand the policy better.</p>
                    <div class="chat-window" id="single-chat-window"></div>
                    <form class="chat-input" id="single-chat-form">
                        <input type="text" id="single-chat-input" placeholder="Ask a question..." autocomplete="off">
                        <button type="submit">Send</button>
                    </form>
                    <button class="proceed-btn" onclick="app.goToStanceScreen()">
                        Proceed to Submit Stance
                    </button>
                </div>

                <!-- Group 2: Dual-AI Negotiation View -->
                <div id="dual-negotiation-view" style="display: none;">
                    <button class="back-btn" onclick="app.goBack()">← Back</button>
                    <h2>Step 2: Observe AI Debate</h2>
                    <p>Watch two AI agents debate opposing sides. Use the clarification chat to ask questions.</p>
                    <button id="start-negotiation-btn" onclick="app.runNegotiation()">Start Debate</button>
                    <div class="chat-window" id="negotiation-window"></div>
                    <div id="tldr-container"></div>
                    <button id="negotiation-proceed-btn" class="proceed-btn" onclick="app.goToStanceScreen()" disabled>
                        Proceed to Submit Stance
                    </button>
                </div>
            </div>

            <!-- This panel is ONLY for Group 2 -->
            <div id="clarification-panel" style="display: none;">
                <h3>Ask Questions</h3>
                <p>Ask the neutral AI for factual clarifications.</p>
                <div class="chat-window" id="clarification-chat-window"></div>
                <form class="chat-input" id="clarification-chat-form">
                    <input type="text" id="clarification-chat-input" placeholder="Ask a question..." autocomplete="off">
                    <button type="submit">Send</button>
                </form>
            </div>
        </div>

        <!-- Screen 4: Stance Submission -->
        <div class="screen" id="stance-submission-screen">
            <button class="back-btn" onclick="app.goBack()">← Back</button>
            <h2>Step 3: Submit Your Stance</h2>
            <p>Write your position on the policy based on what you learned.</p>
            <p><strong>Topic:</strong> <span id="stance-topic-title"></span></p>
            <form id="stance-form" name="stance" netlify netlify-honeypot="bot-field">
                <input type="hidden" name="form-name" value="stance" />
                <p class="hidden">
                    <label>Don’t fill this out if you’re human: <input name="bot-field" /></label>
                </p>
                <textarea id="stance-textarea" name="stance" placeholder="Enter your stance here..."></textarea>
                <input type="hidden" name="submission-data" id="submission-data-input">
                <button type="submit" id="submit-stance-btn" class="proceed-btn">
                    Submit Final Stance
                </button>
            </form>
        </div>

        <!-- Screen 5: Complete -->
        <div class="screen" id="complete-screen">
            <!-- NEW: Added icon -->
            <div class="complete-icon"></div>
            <h2>Thank You!</h2>
            <p>Your participation is complete. Your responses have been recorded for analysis.</p>
            <p>The researcher will now conduct a brief qualitative interview.</p>
        </div>

    </div>

    <!-- Main Application Logic -->
    <script type="module">
        import Groq from "https://esm.sh/groq-sdk";

        // --- 1. CONFIGURATION ---

        // ⚠️ IMPORTANT: Replace with your Groq API key
        const API_KEY = "%%GROQ_API_KEY%%";
        const LLM_MODEL = 'llama-3.1-8b-instant';
        const NEGOTIATION_EXCHANGES = 2; // Number of exchanges per agent (2 FOR, 2 AGAINST = 4 total)
        const MAX_RETRIES = 5; // Max retries for rate limit
        const EXCHANGE_DELAY = 2000; // 2 second delay between exchanges for rate limits

        let groq;
        
        // NEW: Sleep helper function
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // NEW: Helper function to trigger a JSON file download (we'll keep it as a fallback)
        function downloadJSON(data, filename) {
            // 1. Convert the JavaScript object into a JSON string
            const jsonString = JSON.stringify(data, null, 2);
            
            // 2. Create a Blob (Binary Large Object) from the string
            const blob = new Blob([jsonString], { type: 'application/json' });
            
            // 3. Create a temporary URL for the Blob
            const url = URL.createObjectURL(blob);
            
            // 4. Create a temporary, invisible link element
            const a = document.createElement('a');
            a.href = url;
            a.download = filename; // This attribute tells the browser to download the file
            
            // 5. Programmatically click the link to start the download
            document.body.appendChild(a); // The link must be in the DOM to be clicked
            a.click();
            
            // 6. Clean up by removing the link and revoking the temporary URL
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- 2. PERSONAS AND PROBLEMS ---

        const PROBLEMS = {
            'chat-control': {
                title: "EU 'Chat Control' Policy",
                fullText: "The proposed EU 'Chat Control' (CSA Regulation) policy aims to combat child sexual abuse material (CSAM) by requiring providers of interpersonal communication services (like WhatsApp, Signal, or Messenger) to scan all messages, including text, images, and videos, for CSAM. This involves 'client-side scanning' before messages are encrypted. Proponents argue it's a necessary tool to protect children. Opponents, including privacy advocates and security experts, warn that it effectively breaks end-to-end encryption, creates a massive surveillance infrastructure, and is prone to errors, threatening the privacy and security of all EU citizens."
            },
            'ai-policy': {
                title: "EU AI Act Regulations",
                fullText: "The EU AI Act is a proposed regulation that categorizes AI systems based on risk. 'High-risk' systems (e.g., in critical infrastructure, medical devices, or law enforcement) will face strict requirements for transparency, data quality, and human oversight. 'Limited-risk' systems (e.g., chatbots) will have transparency obligations, and 'minimal-risk' systems (e.g., spam filters) will be largely unregulated. Proponents argue this 'risk-based' approach protects fundamental rights and fosters trust in AI. Opponents worry it could be too restrictive, stifle innovation, and be difficult to enforce, putting EU tech companies at a competitive disadvantage."
            },
            'co2-emissions': {
                title: "Man-made CO2 Emissions Impact",
                fullText: "The scientific consensus is that man-made CO2 emissions are the primary driver of current climate change and global warming. This is based on overwhelming evidence from atmospheric measurements, ice core data, and climate models. Proposed solutions often involve transitioning to renewable energy, carbon capture technologies, and international agreements to reduce emissions. However, debates persist regarding the economic feasibility, speed of implementation, and the exact balance between technological solutions and lifestyle changes required to mitigate the worst impacts."
            }
        };

        const PERSONAS = {
            clarification: {
                name: "Neutral Assistant",
                systemPrompt: "You are a neutral AI providing factual information. Answer in 2-3 sentences maximum. No opinions or stances."
            },
            factChecker: {
                name: "Fact Checker",
                systemPrompt: "Fact-check ONE claim from the argument. Write EXACTLY 1-2 sentences. Start with 'Fact check:' and state if accurate or needs context."
            },
            agentFor: {
                name: "Agent For",
                systemPrompt: `You argue FOR the policy. MAXIMUM 3 sentences. First sentence: address opponent's point briefly. Second sentence: state ONE key fact supporting the policy. Third sentence (if needed): cite a source. DO NOT write paragraphs. Be concise and factual.`
            },
            agentAgainst: {
                name: "Agent Against",
                systemPrompt: `You argue AGAINST the policy. MAXIMUM 3 sentences. First sentence: address opponent's point briefly. Second sentence: state ONE key fact opposing the policy. Third sentence (if needed): cite a source. DO NOT write paragraphs. Be concise and factual.`
            },
            summarizer: {
                name: "Summarizer",
                systemPrompt: "Create a TLDR with exactly 3 bullet points: 1) Main FOR argument, 2) Main AGAINST argument, 3) Key tension between them. Each bullet must be ONE sentence only."
            }
        };

        // --- 3. APPLICATION STATE ---

        const appState = {
            participantId: `pid_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`,
            currentScreen: 'welcome-screen',
            interactionMode: null, // 'singleChatbot' or 'dualNegotiation'
            selectedProblemId: null,
            selectedProblem: null,
            isAiThinking: false,
            
            // Data for Logging
            clarificationChatHistory: [],
            singleChatHistory: [],
            negotiationHistory: [],
            userStance: ""
        };

        // --- 4. DOM ELEMENT REFERENCES ---

        const screens = {
            welcome: document.getElementById('welcome-screen'),
            problemSelection: document.getElementById('problem-selection-screen'),
            interaction: document.getElementById('interaction-screen'),
            stanceSubmission: document.getElementById('stance-submission-screen'),
            complete: document.getElementById('complete-screen')
        };

        const elements = {
            problemList: document.getElementById('problem-list'),
            
            // Interaction Screen Components
            singleChatView: document.getElementById('single-chatbot-view'),
            singleChatWindow: document.getElementById('single-chat-window'),
            singleChatForm: document.getElementById('single-chat-form'),
            singleChatInput: document.getElementById('single-chat-input'),

            dualNegotiationView: document.getElementById('dual-negotiation-view'),
            startNegotiationBtn: document.getElementById('start-negotiation-btn'),
            negotiationWindow: document.getElementById('negotiation-window'),
            // NEW: Proceed button for negotiation
            negotiationProceedBtn: document.getElementById('negotiation-proceed-btn'),

            clarificationPanel: document.getElementById('clarification-panel'),
            clarificationChatWindow: document.getElementById('clarification-chat-window'),
            clarificationChatForm: document.getElementById('clarification-chat-form'),
            clarificationChatInput: document.getElementById('clarification-chat-input'),

            // Stance Screen
            stanceTopicTitle: document.getElementById('stance-topic-title'),
            stanceTextarea: document.getElementById('stance-textarea'),
        };

        // --- 5. CORE API FUNCTIONS ---

        /**
         * Original function to get a non-streamed response.
         */
        async function getFullAiResponse(systemPrompt, messageHistory) {
            if (!groq) {
                console.error("Groq not initialized.");
                throw new Error("AI connection not established.");
            }
            
            const messages = [
                { role: "system", content: systemPrompt },
                ...messageHistory
            ];
            
            const completion = await groq.chat.completions.create({
                messages: messages,
                model: LLM_MODEL
            });
            
            return completion.choices[0]?.message?.content || "No response.";
        }

        /**
         * NEW: Wrapper for getFullAiResponse that handles 429 rate limits with exponential backoff.
         */
        async function getFullAiResponseWithBackoff(systemPrompt, messageHistory) {
            let retries = 0;
            let waitTime = 2000; // Initial wait time 2 seconds
            
            while (retries < MAX_RETRIES) {
                try {
                    // We only set isAiThinking right before the actual call
                    appState.isAiThinking = true;
                    const response = await getFullAiResponse(systemPrompt, messageHistory);
                    appState.isAiThinking = false;
                    return response; // Success
                } catch (error) {
                    appState.isAiThinking = false;
                    // Check if it's a Groq rate limit error
                    if (error.status === 429) {
                        retries++;
                        let delay = waitTime;
                        
                        // Try to parse the suggested wait time from the error message
                        try {
                            const errorBody = await error.response.json();
                            const message = errorBody.error.message;
                            const match = message.match(/Please try again in (\d+\.?\d*)s/);
                            if (match && match[1]) {
                                delay = parseFloat(match[1]) * 1000 + 200; // Use suggested time + 200ms buffer
                                console.warn(`Groq Rate Limit. Retrying in ${delay}ms...`);
                            } else {
                                console.warn(`Groq Rate Limit. Retrying in ${delay}ms... (default backoff)`);
                                waitTime *= 2; // Default exponential backoff
                            }
                        } catch (parseError) {
                            console.warn(`Groq Rate Limit. Retrying in ${delay}ms... (default backoff)`);
                            waitTime *= 2; // Default exponential backoff
                        }
                        
                        addMessageToWindow(`Rate limit hit. Waiting for ${Math.round(delay/1000)}s before retrying...`, 'system', elements.negotiationWindow);
                        await sleep(delay);
                    } else {
                        // Not a rate limit error, throw it
                        console.error("Groq API Error:", error);
                        return `Error connecting to AI: ${error.message}`;
                    }
                }
            }
            
            // If we exit the loop, we've exceeded max retries
            throw new Error(`Failed to get response from Groq after ${MAX_RETRIES} retries.`);
        }


        /**
         * UPDATED: Now accepts an `avatarClass` and a `thinkingMessageElement`
         * Generic function to stream an AI response to a chat window.
         */
        async function streamAiResponse(systemPrompt, messageHistory, targetWindow, speakerName, avatarClass = 'avatar-neutral', thinkingMessageElement) {
            if (!groq) {
                console.error("Groq not initialized.");
                addMessageToWindow("Error: AI connection not established.", "system", targetWindow);
                return;
            }
            if (appState.isAiThinking) return;
            appState.isAiThinking = true;

            // Use the provided 'thinking' element
            const msgElement = thinkingMessageElement;
            msgElement.className = `chat-message assistant ${avatarClass}`; // Add final classes
            msgElement.innerHTML = `<strong>${speakerName}</strong><span class="content"></span>`; // Set final structure
            const contentElement = msgElement.querySelector('.content');

            try {
                const messages = [
                    { role: "system", content: systemPrompt },
                    ...messageHistory
                ];

                const stream = await groq.chat.completions.create({
                    messages: messages,
                    model: LLM_MODEL,
                    stream: true
                });

                let fullResponse = "";
                for await (const chunk of stream) {
                    const content = chunk.choices[0]?.delta?.content || "";
                    fullResponse += content;
                    contentElement.textContent = fullResponse; // Update text as it streams
                    targetWindow.scrollTop = targetWindow.scrollHeight;
                }
                return fullResponse; // Return the full response for history logging

            } catch (error) {
                console.error("Groq API Error:", error);
                contentElement.textContent = "Error connecting to AI. Please check the console.";
            } finally {
                appState.isAiThinking = false;
            }
        }

        // --- 6. UI AND STATE MANAGEMENT ---

        function showScreen(screenId) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            screens[screenId].classList.add('active');
            appState.currentScreen = screenId;
        }

        // UPDATED: Now returns the created element
        function addMessageToWindow(text, sender, targetWindow, speakerName = null) {
            const msg = document.createElement('div');
            msg.className = `chat-message ${sender}`; // sender is 'user' or 'assistant' or 'system' or 'assistant agent-a'
            
            let html = "";
            if (speakerName) {
                html += `<strong>${speakerName}</strong>`;
            }
            html += text;
            msg.innerHTML = html;

            targetWindow.appendChild(msg);
            targetWindow.scrollTop = targetWindow.scrollHeight;
            return msg; // Return the element
        }

        function populateProblemList() {
            elements.problemList.innerHTML = "";
            for (const [id, problem] of Object.entries(PROBLEMS)) {
                const btn = document.createElement('button');
                btn.textContent = problem.title;
                btn.onclick = () => app.selectProblem(id);
                elements.problemList.appendChild(btn);
            }
        }
        
        function setupInteractionScreen() {
            const problem = appState.selectedProblem;
            if (!problem) return;

            // Reset views
            elements.singleChatView.style.display = 'none';
            elements.dualNegotiationView.style.display = 'none';
            elements.clarificationPanel.style.display = 'none';

            if (appState.interactionMode === 'singleChatbot') {
                elements.singleChatView.style.display = 'flex';
                // Add problem context to chat
                addMessageToWindow(`<strong>${problem.title}</strong>`, 'system', elements.singleChatWindow);
                appState.singleChatHistory.push({ role: 'system', content: `The selected topic is: ${problem.fullText}` });

            } else if (appState.interactionMode === 'dualNegotiation') {
                elements.dualNegotiationView.style.display = 'flex';
                elements.clarificationPanel.style.display = 'flex';
                // Add problem context to clarification chat
                addMessageToWindow(`<strong>${problem.title}</strong>`, 'system', elements.clarificationChatWindow);
                appState.clarificationChatHistory.push({ role: 'system', content: `The selected topic is: ${problem.fullText}` });
                // Add context to negotiation window
                addMessageToWindow(`<strong>${problem.title}</strong>`, 'system', elements.negotiationWindow);
            }
        }

        // --- 7. APPLICATION LOGIC FLOW (Public Methods) ---

        const app = {
            startSession(mode) {
                console.log(`Starting session for ${mode}`);
                appState.interactionMode = mode;
                populateProblemList();
                showScreen('problemSelection');
            },

            selectProblem(problemId) {
                console.log(`Problem selected: ${problemId}`);
                appState.selectedProblemId = problemId;
                appState.selectedProblem = PROBLEMS[problemId];
                setupInteractionScreen();
                showScreen('interaction');
            },
            
            async handleSingleChatSubmit(event) {
                event.preventDefault();
                const input = elements.singleChatInput;
                const userInput = input.value.trim();
                if (!userInput || appState.isAiThinking) return;
                
                // Add user message to UI and history
                addMessageToWindow(userInput, 'user', elements.singleChatWindow, "You");
                appState.singleChatHistory.push({ role: 'user', content: userInput });
                input.value = "";
                
                // NEW: Add "Thinking..." message and pass it to the stream function
                const thinkingMsg = addMessageToWindow(
                    "Thinking", 
                    "assistant avatar-neutral thinking", 
                    elements.singleChatWindow, 
                    PERSONAS.clarification.name
                );

                // Get AI response
                const aiResponse = await streamAiResponse(
                    PERSONAS.clarification.systemPrompt,
                    appState.singleChatHistory,
                    elements.singleChatWindow,
                    PERSONAS.clarification.name,
                    'avatar-neutral',
                    thinkingMsg // Pass the element to be filled
                );
                
                // Add AI response to history
                if (aiResponse) {
                    appState.singleChatHistory.push({ role: 'assistant', content: aiResponse });
                }
            },
            
            async handleClarificationChatSubmit(event) {
                event.preventDefault();
                const input = elements.clarificationChatInput;
                const userInput = input.value.trim();
                if (!userInput || appState.isAiThinking) return;
                
                // Add user message to UI and history
                addMessageToWindow(userInput, 'user', elements.clarificationChatWindow, "You");
                appState.clarificationChatHistory.push({ role: 'user', content: userInput });
                input.value = "";
                
                // NEW: Add "Thinking..." message and pass it to the stream function
                const thinkingMsg = addMessageToWindow(
                    "Thinking", 
                    "assistant avatar-neutral thinking", 
                    elements.clarificationChatWindow, 
                    PERSONAS.clarification.name
                );
                
                // Get AI response
                const aiResponse = await streamAiResponse(
                    PERSONAS.clarification.systemPrompt,
                    appState.clarificationChatHistory,
                    elements.clarificationChatWindow,
                    PERSONAS.clarification.name,
                    'avatar-neutral',
                    thinkingMsg // Pass the element to be filled
                );
                
                // Add AI response to history
                if (aiResponse) {
                    appState.clarificationChatHistory.push({ role: 'assistant', content: aiResponse });
                }
            },

            async runNegotiation() {
                console.log("Running negotiation...");
                elements.startNegotiationBtn.disabled = true;
                elements.startNegotiationBtn.innerHTML = '<span class="spinner"></span> Debate in Progress...';

                const problemText = appState.selectedProblem.fullText;
                let negotiationMessageHistory = [
                    { role: 'user', content: `The policy to be debated is: ${problemText}. Provide your opening statement with evidence-based arguments.` }
                ];

                appState.negotiationHistory = [];

                try {
                    for (let i = 0; i < NEGOTIATION_EXCHANGES * 2; i++) {
                        const isAgentFor = i % 2 === 0;
                        const agent = isAgentFor ? PERSONAS.agentFor : PERSONAS.agentAgainst;
                        const agentClass = isAgentFor ? 'agent-for' : 'agent-against';

                        // Get agent response
                        const aiResponse = await getFullAiResponseWithBackoff(agent.systemPrompt, negotiationMessageHistory);
                        addMessageToWindow(aiResponse, `assistant ${agentClass}`, elements.negotiationWindow, agent.name);

                        appState.negotiationHistory.push({ speaker: agent.name, text: aiResponse });
                        negotiationMessageHistory.push({ role: 'assistant', content: aiResponse });

                        // Add fact-checking after every exchange pair
                        if (i % 2 === 1 && i < NEGOTIATION_EXCHANGES * 2 - 1) {
                            await sleep(EXCHANGE_DELAY);
                            const factCheckPrompt = [
                                { role: 'user', content: `Review this argument: "${aiResponse}". Fact-check one key claim.` }
                            ];
                            const factCheck = await getFullAiResponseWithBackoff(PERSONAS.factChecker.systemPrompt, factCheckPrompt);
                            addMessageToWindow(factCheck, 'assistant fact-checker', elements.negotiationWindow, PERSONAS.factChecker.name);
                        }

                        negotiationMessageHistory.push({ role: 'user', content: "Respond to the previous argument with evidence." });
                        await sleep(EXCHANGE_DELAY);
                    }

                    addMessageToWindow("Debate complete.", 'system', elements.negotiationWindow);

                    // Generate TLDR
                    const tldrPrompt = [
                        { role: 'user', content: `Summarize this debate in 3-4 bullet points:\n${appState.negotiationHistory.map(h => `${h.speaker}: ${h.text}`).join('\n\n')}` }
                    ];
                    const tldr = await getFullAiResponseWithBackoff(PERSONAS.summarizer.systemPrompt, tldrPrompt);

                    // Display TLDR
                    const tldrContainer = document.getElementById('tldr-container');
                    tldrContainer.innerHTML = `<div class="tldr-section"><h3>Summary</h3>${tldr.replace(/\n/g, '<br>')}</div>`;

                    elements.startNegotiationBtn.textContent = "Debate Complete";
                    elements.negotiationProceedBtn.disabled = false;
                    elements.negotiationProceedBtn.textContent = "Proceed to Submit Stance";

                } catch (error) {
                    console.error("Negotiation failed:", error);
                    addMessageToWindow(`Error: ${error.message}`, 'system', elements.negotiationWindow);
                    elements.startNegotiationBtn.textContent = "Debate Failed";
                    elements.startNegotiationBtn.style.backgroundColor = 'red';
                }
            },
            
            // Function to move to the stance screen
            goToStanceScreen() {
                console.log("Proceeding to stance submission.");
                elements.stanceTopicTitle.textContent = appState.selectedProblem.title;
                showScreen('stanceSubmission');
            },

            // Back button navigation
            goBack() {
                const currentScreen = appState.currentScreen;
                if (currentScreen === 'problemSelection') {
                    showScreen('welcome');
                } else if (currentScreen === 'interaction') {
                    showScreen('problemSelection');
                } else if (currentScreen === 'stanceSubmission') {
                    showScreen('interaction');
                }
            },

            // Custom topic selection
            selectCustomTopic() {
                const title = document.getElementById('custom-topic-title').value.trim();
                const description = document.getElementById('custom-topic-description').value.trim();

                if (!title || !description) {
                    alert('Please provide both a title and description for your custom topic.');
                    return;
                }

                // Create a custom problem object
                const customId = 'custom-' + Date.now();
                PROBLEMS[customId] = {
                    title: title,
                    fullText: description
                };

                app.selectProblem(customId);
            },

            async submitStance(event) {
                event.preventDefault(); // Prevent default form submission
                const stance = elements.stanceTextarea.value.trim();
                if (!stance) {
                    elements.stanceTextarea.style.borderColor = 'red';
                    elements.stanceTextarea.placeholder = "Please enter your stance before submitting.";
                    return;
                }

                elements.stanceTextarea.style.borderColor = 'var(--border-color)';
                appState.userStance = stance;

                const finalData = {
                    participantId: appState.participantId,
                    interactionMode: appState.interactionMode,
                    problemId: appState.selectedProblemId,
                    problemTitle: appState.selectedProblem.title,
                    userStance: appState.userStance,
                    logs: {
                        singleChatHistory: appState.singleChatHistory,
                        clarificationChatHistory: appState.clarificationChatHistory,
                        negotiationHistory: appState.negotiationHistory
                    }
                };

                // Populate the hidden input with the JSON data
                document.getElementById('submission-data-input').value = JSON.stringify(finalData, null, 2);

                const formData = new FormData(event.target);
                fetch("/", {
                    method: "POST",
                    headers: { "Content-Type": "application/x-www-form-urlencoded" },
                    body: new URLSearchParams(formData).toString()
                }).then(() => showScreen('complete')).catch((error) => alert(error));

            }
        };
        
        // --- 8. INITIALIZATION ---

        function init() {
            // Initialize Groq SDK
            if (API_KEY && !API_KEY.includes("YOUR_")) {
                try {
                    groq = new Groq({ apiKey: API_KEY, dangerouslyAllowBrowser: true });
                    console.log("Groq SDK Initialized.");
                } catch(e) { 
                    console.error("Failed to initialize Groq SDK:", e); 
                    // Use a non-blocking error display
                    const header = document.querySelector('header h1');
                    if (header) {
                        header.textContent = "Error: AI Connection Failed. Check Console.";
                        header.style.color = "#ffcccc";
                    }
                }
            } else {
                console.warn("API Key missing. AI features will be offline.");
                const header = document.querySelector('header h1');
                if (header) {
                    header.textContent = "CRITICAL: Groq API Key is missing. App offline.";
                    header.style.color = "#ffcccc";
                }
            }

            elements.stanceForm = document.getElementById('stance-form');

            // --- Add Event Listeners ---
            elements.singleChatForm.addEventListener('submit', app.handleSingleChatSubmit);
            elements.clarificationChatForm.addEventListener('submit', app.handleClarificationChatSubmit);
            elements.stanceForm.addEventListener('submit', app.submitStance);
            
            // Make app object globally accessible for HTML onclick attributes
            window.app = app;
            
            console.log("Application Initialized.");
        }

        init();
    </script>
</body>
</html>



