<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civic Engagement AI Interaction Study</title>

    <!-- Open Graph meta tags for link previews -->
    <meta property="og:title" content="Civic Engagement AI Interaction Study">
    <meta property="og:description" content="Interactive research study exploring AI-assisted decision-making on civic topics through single-chatbot dialogue and dual-AI debate formats.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://civic-ai-debate.netlify.app/">

    <link rel="icon" href="assets/logo.svg" type="image/svg+xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
    
    <!-- This allows the Groq SDK to run in a browser environment -->

    
    <style>
        :root {
            /* Cool, subtle color palette */
            --bg-color: #f5f1ed;
            --text-color: #3d4247;
            --primary-color: #2c3e50;
            --primary-hover: #1e2d3d;
            --secondary-color: #e8e9ea;
            --border-color: #c5c8ca;
            --container-bg: #fafaf8;
            --shadow: 0 2px 8px rgba(61, 66, 71, 0.08);
            --shadow-lg: 0 8px 24px rgba(61, 66, 71, 0.12);
            --green-btn: #2c3e50;
            --green-btn-hover: #1e2d3d;

            /* Agent colors - cool, muted tones */
            --agent-for-bg: #dff0e8;
            --agent-for-border: #4a8c6f;
            --agent-for-accent: #c5e4d9;
            --agent-against-bg: #f5e6e6;
            --agent-against-border: #b56b6b;
            --agent-against-accent: #e8d0d0;
            --neutral-bg: #e3e7f5;
            --neutral-border: #6b7bb8;
        }

        /* Responsive base font size */
        html { font-size: 100%; }

        /* Hide honeypot field for spam protection */
        .hidden { display: none; }

        body {
            background: #000000;
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
            padding: 2rem 1rem;
            box-sizing: border-box;
        }

        #app-container {
            width: 100%;
            max-width: 1400px;
            min-height: 90vh;
            background: var(--container-bg);
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, #1e2d3d 0%, #2c3e50 100%);
            color: #f5f1ed;
            padding: 2.5rem 2rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 2px solid var(--primary-color);
        }

        header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            font-family: 'Space Grotesk', sans-serif;
            color: #e8dfd5;
        }

        .screen { display: none; }
        .screen.active {
            display: flex;
            flex-direction: column;
            padding: 3rem;
            gap: 2rem;
            flex-grow: 1;
            background: var(--bg-color);
        }

        h2 {
            color: var(--text-color);
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-size: 2.75rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            font-family: 'Space Grotesk', sans-serif;
        }

        /* Step titles - smaller than welcome */
        #problem-selection-screen h2,
        #interaction-screen h2,
        #stance-screen h2 {
            font-size: 1.75rem;
        }

        h3 {
            color: var(--text-color);
            font-size: 1.35rem;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 0.75rem;
            font-family: 'Space Grotesk', sans-serif;
        }

        p, li {
            line-height: 1.7;
            font-size: 1rem;
            color: #5d6369;
        }

        button {
            background-color: var(--primary-color);
            color: #ffffff;
            border: none;
            padding: 0.875rem 1.75rem;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
            box-shadow: var(--shadow);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            letter-spacing: 0.01em;
        }
        button:hover {
            background-color: var(--primary-hover);
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #b8bcc1;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
            opacity: 0.6;
        }
        
        /* Welcome Screen Button Group */
        .welcome-button-group {
            display: flex;
            flex-direction: row;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 2rem;
        }
        .welcome-button-group button {
            background-color: var(--container-bg);
            color: var(--text-color);
            text-align: left;
            border: 2px solid var(--border-color);
            flex: 1;
            max-width: 350px;
            display: flex;
            align-items: center;
            padding: 2rem 1.5rem;
            transition: all 0.25s ease;
            box-shadow: var(--shadow);
        }
        .welcome-button-group button:hover {
            background-color: var(--container-bg);
            border-color: var(--primary-color);
            box-shadow: 0 10px 30px rgba(45, 37, 32, 0.15);
            transform: translateY(-3px);
        }
        .welcome-button-group button div {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--text-color);
            font-family: 'Space Grotesk', sans-serif;
        }
        .welcome-button-group button span {
            font-weight: 400;
            font-size: 0.9rem;
            color: #5d6369;
        }
        
        /* ASSET: Button Icons */
        .button-icon {
            width: 48px;
            height: 48px;
            margin-right: 1.5rem;
            background-color: var(--secondary-color);
            border-radius: 8px;
            padding: 8px;
            object-fit: contain;
        }

        /* Problem Selection Buttons */
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .button-group button {
            background-color: var(--container-bg);
            color: var(--text-color);
            text-align: left;
            border: 2px solid var(--border-color);
            padding: 1.125rem 1.5rem;
            font-size: 1rem;
        }
        .button-group button:hover {
            background-color: var(--container-bg);
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        /* UPDATED: Layout Fix */
        #interaction-screen {
            flex-direction: row;
            gap: 2rem;
            flex-grow: 1; /* This makes the screen fill its parent */
            overflow: hidden; /* Prevent child overflow */
        }

        #main-interaction, #clarification-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            background: var(--container-bg);
            height: 100%;
            box-sizing: border-box;
            box-shadow: var(--shadow);
        }

        /* Give more space to debate panel */
        #main-interaction { flex: 2; }
        #clarification-panel { flex: 1; }
        #single-chatbot-view { width: 100%; }

        /* UPDATED: This container now fills height */
        #single-chatbot-view, #dual-debate-view {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Chat window styling */
        .chat-window {
            flex-grow: 1;
            min-height: 300px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-color);
            padding: 1.25rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .chat-message {
            padding: 0.875rem 1.25rem;
            border-radius: 10px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 0.95rem;
        }
        .chat-message.user {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-hover) 100%);
            color: #ffffff;
            align-self: flex-end;
            border-radius: 12px 12px 2px 12px;
            box-shadow: var(--shadow);
        }
        .chat-message.assistant {
            background: var(--container-bg);
            color: var(--text-color);
            align-self: flex-start;
            border-radius: 12px 12px 12px 2px;
            border: 2px solid var(--border-color);
            position: relative;
            padding-left: 60px;
            min-height: 40px;
        }
        
        /* UPDATED: Avatar styling */
        .chat-message.assistant::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 10px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ccc; /* Fallback */
            /* FIX: Use contain for SVGs */
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* ASSET: Neutral Avatar */
        .chat-message.assistant.avatar-neutral::before {
            /* FIX: Path: 'assets/avatar-neutral.svg' */
            background-image: url('assets/avatar-neutral.svg');
        }
        /* ASSET: Agent For Avatar */
        .chat-message.agent-for::before {
            background-image: url('assets/avatar-alpha.svg');
        }
        /* ASSET: Agent Against Avatar */
        .chat-message.agent-against::before {
            background-image: url('assets/avatar-beta.svg');
        }
        /* ASSET: Fact Checker Avatar */
        .chat-message.fact-checker::before {
            background-image: url('assets/avatar-neutral.svg');
        }
        
        /* NEW: "Thinking" message styling */
        .chat-message.thinking {
            font-style: italic;
            color: #555;
        }
        /* "Thinking" dots animation */
        .chat-message.thinking::after {
            content: '.';
            animation: dots 1s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: "."; }
            40% { content: ".."; }
            60%, 80%, 100% { content: "..."; }
        }

        .chat-message strong {
            display: block;
            margin-bottom: 0.25rem;
            font-family: 'Inter', sans-serif;
            color: var(--primary-color);
            font-size: 0.9rem;
        }
        .chat-message.assistant strong { color: #555; }
        
        /* System message styling */
        .chat-message.system {
            background: var(--secondary-color);
            color: #5b6570;
            border: 1px solid var(--border-color);
            align-self: center;
            font-size: 0.875rem;
            width: 100%;
            max-width: 100%;
            text-align: center;
            box-sizing: border-box;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-weight: 500;
        }

        /* Topic introduction message styling */
        .chat-message.topic-intro {
            background: #fffaeb;
            color: #3d4247;
            border: 1px solid #f7e7b3;
            align-self: center;
            font-size: 0.9rem;
            width: 100%;
            max-width: 100%;
            text-align: center;
            box-sizing: border-box;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-weight: 500;
        }

        .chat-input {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .chat-input input {
            flex-grow: 1;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
            transition: all 0.15s ease;
        }
        .chat-input input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        #stance-submission-screen textarea {
            width: 100%;
            height: 250px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.95rem;
            font-family: 'Inter', sans-serif;
            resize: vertical;
            box-sizing: border-box;
            transition: all 0.15s ease;
            line-height: 1.6;
        }
        #stance-submission-screen textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        /* Agent-specific colors */
        #dual-debate-view .chat-message.agent-for {
            background: var(--agent-for-bg);
            border: 2px solid var(--agent-for-border);
            border-left-width: 4px;
        }
        #dual-debate-view .chat-message.agent-against {
            background: var(--agent-against-bg);
            border: 2px solid var(--agent-against-border);
            border-left-width: 4px;
        }
        #dual-debate-view .chat-message.agent-for strong {
            color: var(--agent-for-border);
            font-weight: 700;
        }
        #dual-debate-view .chat-message.agent-against strong {
            color: var(--agent-against-border);
            font-weight: 700;
        }
        #dual-debate-view .chat-message.fact-checker {
            background: var(--neutral-bg);
            border: 2px solid var(--neutral-border);
            border-left-width: 4px;
            font-size: 0.9rem;
        }
        #dual-debate-view .chat-message.fact-checker strong {
            color: var(--neutral-border);
            font-weight: 700;
        }
        
        /* Proceed Button Styling */
        .proceed-btn {
            background-color: var(--green-btn);
            width: 100%;
            margin-top: 1rem;
            padding: 1rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
        }
        .proceed-btn:hover {
            background-color: var(--green-btn-hover);
        }
        .proceed-btn:disabled {
            background-color: #9ca3af;
            box-shadow: none;
            transform: none;
            opacity: 0.6;
        }
        
        /* NEW: Final Screen Styling */
        #complete-screen {
            text-align: center;
            justify-content: center;
            align-items: center;
        }
        .complete-icon {
            width: 60px;
            height: 60px;
            /* ASSET: Path: 'assets/icon-complete.svg' */
            background: url('assets/icon-complete.svg') no-repeat center center;
            background-size: contain;
            background-color: #e6f0ed;
            border-radius: 50%;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        /* Loading spinner */
        .spinner {
            width: 1.25em;
            height: 1.25em;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* TLDR Section */
        .tldr-section {
            background: linear-gradient(135deg, #f0f1f3 0%, #e8eaed 100%);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.25rem 0;
            box-shadow: var(--shadow);
        }
        .tldr-section h3 {
            margin: 0 0 1rem 0;
            color: var(--primary-color);
            font-size: 1.2rem;
            font-weight: 700;
        }
        .tldr-section ul {
            margin: 0.5rem 0 0 0;
            padding-left: 1.75rem;
            line-height: 1.9;
        }
        .tldr-section li {
            margin-bottom: 1rem;
            color: var(--text-color);
            font-size: 1rem;
        }
        .tldr-section li:last-child {
            margin-bottom: 0;
        }

        /* Back button styling */
        .back-btn {
            background-color: var(--primary-color);
            margin-bottom: 1.5rem;
            padding: 0.65rem 1.25rem;
            font-size: 0.9rem;
            align-self: flex-start;
            font-weight: 500;
        }
        .back-btn:hover {
            background-color: var(--primary-hover);
        }

        /* Mobile Responsive Styles */
        @media screen and (max-width: 768px) {
            body {
                padding: 0.5rem;
            }

            #app-container {
                max-width: 100%;
                min-height: 100vh;
                border-radius: 8px;
            }

            header {
                padding: 1.5rem 1rem;
            }

            header h1 {
                font-size: 1.5rem;
            }

            .screen.active {
                padding: 1.5rem 1rem;
                gap: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            p, li {
                font-size: 0.95rem;
            }

            button {
                padding: 0.75rem 1.5rem;
                font-size: 0.9rem;
            }

            .welcome-button-group {
                flex-direction: column;
                gap: 1rem;
            }

            .welcome-button-group button {
                max-width: 100%;
                padding: 1.5rem 1rem;
            }

            .button-icon {
                width: 40px;
                height: 40px;
            }

            .button-group button {
                padding: 1rem 1.25rem;
                font-size: 0.95rem;
            }

            #interaction-screen {
                flex-direction: column;
                gap: 1.5rem;
            }

            #main-interaction, #clarification-panel {
                padding: 1.5rem;
                box-sizing: border-box;
                max-width: 100%;
            }

            .chat-window {
                min-height: 250px;
                overflow-x: hidden;
                width: 100%;
                box-sizing: border-box;
            }

            .chat-message {
                max-width: 95%;
                font-size: 0.9rem;
                padding: 0.75rem 1rem;
                overflow-wrap: break-word;
                word-wrap: break-word;
                word-break: break-word;
            }

            .chat-message.assistant {
                padding-left: 50px;
            }

            .chat-message.assistant::before {
                width: 35px;
                height: 35px;
                left: 8px;
                top: 8px;
            }

            .chat-input input {
                font-size: 0.9rem;
                padding: 0.65rem 0.85rem;
            }

            #stance-submission-screen textarea {
                height: 200px;
                font-size: 0.9rem;
                padding: 0.85rem;
            }

            .tldr-section {
                padding: 1.25rem;
            }

            .tldr-section h3 {
                font-size: 1.1rem;
            }

            .tldr-section li {
                font-size: 0.95rem;
            }

            .back-btn {
                padding: 0.6rem 1rem;
                font-size: 0.85rem;
            }
        }

        @media screen and (max-width: 480px) {
            body {
                padding: 0.25rem;
            }

            #app-container {
                border-radius: 4px;
            }

            header {
                padding: 1.25rem 0.75rem;
            }

            header h1 {
                font-size: 1.25rem;
            }

            .screen.active {
                padding: 1.25rem 0.85rem;
                gap: 1.25rem;
            }

            h2 {
                font-size: 1.25rem;
            }

            p, li {
                font-size: 0.9rem;
            }

            button {
                padding: 0.7rem 1.25rem;
                font-size: 0.85rem;
            }

            .welcome-button-group button {
                padding: 1.25rem 0.85rem;
            }

            .button-icon {
                width: 35px;
                height: 35px;
            }

            .button-group button {
                padding: 0.9rem 1rem;
                font-size: 0.9rem;
            }

            #main-interaction, #clarification-panel {
                padding: 1.25rem;
                box-sizing: border-box;
                max-width: 100%;
            }

            .chat-window {
                min-height: 200px;
                padding: 1rem;
                overflow-x: hidden;
                width: 100%;
                box-sizing: border-box;
            }

            .chat-message {
                font-size: 0.85rem;
                padding: 0.65rem 0.85rem;
                overflow-wrap: break-word;
                word-wrap: break-word;
                word-break: break-word;
            }

            .chat-message.assistant {
                padding-left: 45px;
            }

            .chat-message.assistant::before {
                width: 30px;
                height: 30px;
                left: 6px;
                top: 6px;
            }

            .chat-input {
                gap: 0.5rem;
            }

            .chat-input input {
                font-size: 0.85rem;
                padding: 0.6rem 0.75rem;
            }

            #stance-submission-screen textarea {
                height: 180px;
                font-size: 0.85rem;
                padding: 0.75rem;
            }

            .tldr-section {
                padding: 1rem;
            }

            .tldr-section h3 {
                font-size: 1rem;
            }

            .tldr-section li {
                font-size: 0.85rem;
                line-height: 1.6;
            }

            .back-btn {
                padding: 0.55rem 0.9rem;
                font-size: 0.8rem;
            }

            .chat-message.topic-intro,
            .chat-message.system {
                font-size: 0.85rem;
                padding: 0.65rem 0.85rem;
            }
        }

    </style>
</head>
<body>

    <div id="app-container">
        <header>
            <h1>Civic Engagement AI Interaction Study</h1>
        </header>

        <!-- Screen 1: Welcome & Group Assignment -->
        <div class="screen active" id="welcome-screen">
            <h2>Welcome</h2>
            <p>Thank you for participating in this research study on AI-assisted decision-making. Your task will be to review a complex policy topic, use an AI tool to understand it, and then provide your stance on the matter.</p>
            <p>Please select your assigned group to begin.</p>
            <!-- UPDATED: Button layout and icons -->
            <div class="welcome-button-group">
                <button onclick="app.startSession('singleChatbot')">
                    <!-- ASSET: Path: 'assets/icon-single-chat.svg' -->
                    <img src="assets/icon-single-chat.svg" alt="" class="button-icon" 
                         onerror="this.style.display='none'">
                    <div>Start as Group 1<br><span>(Single Chatbot)</span></div>
                </button>
                <button onclick="app.startSession('dualDebate')">
                    <!-- ASSET: Path: 'assets/icon-dual-chat.svg' -->
                    <img src="assets/icon-dual-chat.svg" alt="" class="button-icon"
                         onerror="this.style.display='none'">
                    <div>Start as Group 2<br><span>(Dual-AI Debate)</span></div>
                </button>
            </div>
        </div>

        <!-- Screen 2: Problem Selection -->
        <div class="screen" id="problem-selection-screen">
            <button class="back-btn" onclick="app.goBack()">← Back</button>
            <h2>Step 1: Select a Policy Topic</h2>
            <p>Choose a topic to explore, or define your own below.</p>
            <div class="button-group" id="problem-list">
                <!-- Problems will be dynamically inserted here -->
            </div>
            <div style="margin-top: 2rem;">
                <h3 style="font-size: 1.1rem; margin-bottom: 0.5rem;">Or define your own topic:</h3>
                <input type="text" id="custom-topic-title" placeholder="Topic title (e.g., Universal Basic Income)" style="width: 100%; padding: 0.75rem; margin-bottom: 0.5rem; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem;">
                <textarea id="custom-topic-description" placeholder="Brief description of the topic and key points of debate..." style="width: 100%; height: 100px; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem; resize: vertical;"></textarea>
                <button onclick="app.selectCustomTopic()" style="margin-top: 0.5rem;">Use Custom Topic</button>
            </div>
        </div>

        <!-- Screen 3: Interaction -->
        <div class="screen" id="interaction-screen">
            <!-- This panel is for Group 1 (Main) and Group 2 (Main) -->
            <div id="main-interaction">
                <!-- Group 1: Single Chatbot View -->
                <div id="single-chatbot-view" style="display: none;">
                    <button class="back-btn" onclick="app.goBack()">← Back</button>
                    <h2>Step 2: Explore the Topic</h2>
                    <p>Ask questions to understand the policy better.</p>
                    <div class="chat-window" id="single-chat-window"></div>
                    <form class="chat-input" id="single-chat-form">
                        <input type="text" id="single-chat-input" placeholder="Ask a question..." autocomplete="off">
                        <button type="submit">Send</button>
                    </form>
                    <button class="proceed-btn" onclick="app.goToStanceScreen()">
                        Proceed to Submit Stance
                    </button>
                </div>

                <!-- Group 2: Dual-AI Debate View -->
                <div id="dual-debate-view" style="display: none;">
                    <button class="back-btn" onclick="app.goBack()">← Back</button>
                    <h2>Step 2: Observe AI Debate</h2>
                    <p>Watch two AI agents debate opposing sides. Use the clarification chat to ask questions.</p>
                    <button id="start-debate-btn" onclick="app.runDebate()">Start Debate</button>
                    <div class="chat-window" id="debate-window"></div>
                    <div id="tldr-container"></div>
                    <button id="debate-proceed-btn" class="proceed-btn" onclick="app.goToStanceScreen()" disabled>
                        Proceed to Submit Stance
                    </button>
                </div>
            </div>

            <!-- This panel is ONLY for Group 2 -->
            <div id="clarification-panel" style="display: none;">
                <h3>Ask Questions</h3>
                <p>Ask the neutral AI for factual clarifications.</p>
                <div class="chat-window" id="clarification-chat-window"></div>
                <form class="chat-input" id="clarification-chat-form">
                    <input type="text" id="clarification-chat-input" placeholder="Ask a question..." autocomplete="off">
                    <button type="submit">Send</button>
                </form>
            </div>
        </div>

        <!-- Screen 4: Stance Submission -->
        <div class="screen" id="stance-submission-screen">
            <button class="back-btn" onclick="app.goBack()">← Back</button>
            <h2>Step 3: Submit Your Stance</h2>
            <p>Write your position on the policy based on what you learned.</p>
            <p><strong>Topic:</strong> <span id="stance-topic-title"></span></p>
            <form id="stance-form" name="stance" netlify netlify-honeypot="bot-field">
                <input type="hidden" name="form-name" value="stance" />
                <p class="hidden">
                    <label>Don’t fill this out if you’re human: <input name="bot-field" /></label>
                </p>
                <textarea id="stance-textarea" name="stance" placeholder="Enter your stance here..."></textarea>
                <input type="hidden" name="submission-data" id="submission-data-input">
                <button type="submit" id="submit-stance-btn" class="proceed-btn">
                    Submit Final Stance
                </button>
            </form>
        </div>

        <!-- Screen 5: Complete -->
        <div class="screen" id="complete-screen">
            <!-- NEW: Added icon -->
            <div class="complete-icon"></div>
            <h2>Thank You!</h2>
            <p>Your participation is complete. Your responses have been recorded for analysis.</p>
            <p>The researcher will now conduct a brief qualitative interview.</p>
        </div>

    </div>

    <!-- Main Application Logic -->
    <script type="module">
        import Groq from "https://esm.sh/groq-sdk";

        // --- 1. CONFIGURATION ---

        // ⚠️ IMPORTANT: Replace with your API keys
        const API_KEY = "%%GROQ_API_KEY%%";
        const TAVILY_API_KEY = "%%TAVILY_API_KEY%%";
        const LLM_MODEL = 'llama-3.1-8b-instant';
        const DEBATE_EXCHANGES = 2; // Number of exchanges per agent (2 FOR, 2 AGAINST = 4 total)
        const MAX_RETRIES = 5; // Max retries for rate limit
        const EXCHANGE_DELAY = 2000; // 2 second delay between exchanges for rate limits

        // Token limits for different agent types to enforce response length
        const TOKEN_LIMITS = {
            debateAgent: 120,      // ~3 sentences for debate agents (FOR/AGAINST)
            factChecker: 80,       // ~1-2 sentences for fact checker
            clarification: 100,    // ~2-3 sentences for clarification
            summarizer: 120,       // Summary points
            topicIntro: 80         // Brief introduction
        };

        let groq;

        // NEW: Sleep helper function
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Helper function to truncate response to maximum sentence count
        function truncateToSentences(text, maxSentences = 3) {
            if (!text) return text;

            // Split by sentence endings (., !, ?)
            const sentenceRegex = /[^.!?]+[.!?]+/g;
            const sentences = text.match(sentenceRegex);

            if (!sentences || sentences.length <= maxSentences) {
                return text.trim();
            }

            // Take only the first maxSentences
            const truncated = sentences.slice(0, maxSentences).join('').trim();
            console.warn(`Response truncated from ${sentences.length} to ${maxSentences} sentences`);
            return truncated;
        }

        // NEW: Tavily AI Search function
        async function searchTavily(query) {
            if (!TAVILY_API_KEY || TAVILY_API_KEY.includes("%%")) {
                console.warn("Tavily API key not configured. Skipping search.");
                return null;
            }

            try {
                const response = await fetch('https://api.tavily.com/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        api_key: TAVILY_API_KEY,
                        query: query,
                        search_depth: 'basic',
                        include_answer: true,
                        max_results: 3
                    })
                });

                const data = await response.json();

                if (data.answer) {
                    return {
                        answer: data.answer,
                        results: data.results || []
                    };
                }
                return null;
            } catch (error) {
                console.error("Tavily search error:", error);
                return null;
            }
        }

        // NEW: Helper function to trigger a JSON file download (we'll keep it as a fallback)
        function downloadJSON(data, filename) {
            // 1. Convert the JavaScript object into a JSON string
            const jsonString = JSON.stringify(data, null, 2);
            
            // 2. Create a Blob (Binary Large Object) from the string
            const blob = new Blob([jsonString], { type: 'application/json' });
            
            // 3. Create a temporary URL for the Blob
            const url = URL.createObjectURL(blob);
            
            // 4. Create a temporary, invisible link element
            const a = document.createElement('a');
            a.href = url;
            a.download = filename; // This attribute tells the browser to download the file
            
            // 5. Programmatically click the link to start the download
            document.body.appendChild(a); // The link must be in the DOM to be clicked
            a.click();
            
            // 6. Clean up by removing the link and revoking the temporary URL
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- 2. PERSONAS AND PROBLEMS ---

        const PROBLEMS = {
            'chat-control': {
                title: "EU 'Chat Control' Policy",
                fullText: "The proposed EU 'Chat Control' (CSA Regulation) policy aims to combat child sexual abuse material (CSAM) by requiring providers of interpersonal communication services (like WhatsApp, Signal, or Messenger) to scan all messages, including text, images, and videos, for CSAM. This involves 'client-side scanning' before messages are encrypted. Proponents argue it's a necessary tool to protect children. Opponents, including privacy advocates and security experts, warn that it effectively breaks end-to-end encryption, creates a massive surveillance infrastructure, and is prone to errors, threatening the privacy and security of all EU citizens."
            },
            'ai-policy': {
                title: "EU AI Act Regulations",
                fullText: "The EU AI Act is a proposed regulation that categorizes AI systems based on risk. 'High-risk' systems (e.g., in critical infrastructure, medical devices, or law enforcement) will face strict requirements for transparency, data quality, and human oversight. 'Limited-risk' systems (e.g., chatbots) will have transparency obligations, and 'minimal-risk' systems (e.g., spam filters) will be largely unregulated. Proponents argue this 'risk-based' approach protects fundamental rights and fosters trust in AI. Opponents worry it could be too restrictive, stifle innovation, and be difficult to enforce, putting EU tech companies at a competitive disadvantage."
            },
            'co2-emissions': {
                title: "Man-made CO2 Emissions Impact",
                fullText: "The scientific consensus is that man-made CO2 emissions are the primary driver of current climate change and global warming. This is based on overwhelming evidence from atmospheric measurements, ice core data, and climate models. Proposed solutions often involve transitioning to renewable energy, carbon capture technologies, and international agreements to reduce emissions. However, debates persist regarding the economic feasibility, speed of implementation, and the exact balance between technological solutions and lifestyle changes required to mitigate the worst impacts."
            }
        };

        const PERSONAS = {
            clarification: {
                name: "Neutral Assistant",
                systemPrompt: "You are a neutral AI providing factual information. You MUST answer in EXACTLY 2-3 sentences. No more. Count your sentences carefully. No opinions or stances.",
                maxTokens: TOKEN_LIMITS.clarification,
                maxSentences: 3
            },
            factChecker: {
                name: "Fact Checker",
                systemPrompt: "You have access to web-sourced verification data. Fact-check ONE claim from the argument using the provided information. You MUST write EXACTLY 1-2 sentences. Start with 'Fact check:' and state if accurate, misleading, or needs context. DO NOT EXCEED 2 SENTENCES.",
                maxTokens: TOKEN_LIMITS.factChecker,
                maxSentences: 2
            },
            agentFor: {
                name: "Agent For",
                systemPrompt: `You are one of two AI agents engaged in a structured debate. You will be assigned a position to argue FOR in each exchange. Present arguments that support your assigned position using a narrative, accessible style. Tell a compelling story with real-world examples. When you cite sources, simply write [source] after the claim.

CRITICAL RULE: You MUST respond in EXACTLY 3 sentences or fewer. Count each sentence. Period. If you write more than 3 sentences, your response will be cut off. Be conversational and engaging within this strict limit.`,
                maxTokens: TOKEN_LIMITS.debateAgent,
                maxSentences: 3
            },
            agentAgainst: {
                name: "Agent Against",
                systemPrompt: `You are one of two AI agents engaged in a structured debate. You will be assigned a position to argue AGAINST in each exchange. Present arguments that oppose your assigned position using a narrative, accessible style. Tell a compelling story about concerns, risks, or limitations with real-world examples. When you cite sources, simply write [source] after the claim.

CRITICAL RULE: You MUST respond in EXACTLY 3 sentences or fewer. Count each sentence. Period. If you write more than 3 sentences, your response will be cut off. Be conversational and engaging within this strict limit.`,
                maxTokens: TOKEN_LIMITS.debateAgent,
                maxSentences: 3
            },
            summarizer: {
                name: "Summarizer",
                systemPrompt: "Create exactly 3 summary points. Write:\nFOR: [One sentence summarizing the best argument in favor]\nAGAINST: [One sentence summarizing the best argument against]\nCONCLUSION: [One sentence about the key tension or tradeoff]\n\nKeep each sentence under 20 words. Be clear and direct.",
                maxTokens: TOKEN_LIMITS.summarizer,
                maxSentences: null  // Has its own format
            }
        };

        // --- 3. APPLICATION STATE ---

        const appState = {
            participantId: `pid_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`,
            currentScreen: 'welcome-screen',
            interactionMode: null, // 'singleChatbot' or 'dualDebate'
            selectedProblemId: null,
            selectedProblem: null,
            isAiThinking: false,

            // Data for Logging
            clarificationChatHistory: [],
            singleChatHistory: [],
            debateHistory: [],
            userStance: "",

            // Current source URLs for citations
            currentSourceUrls: []
        };

        // --- 4. DOM ELEMENT REFERENCES ---

        const screens = {
            welcome: document.getElementById('welcome-screen'),
            problemSelection: document.getElementById('problem-selection-screen'),
            interaction: document.getElementById('interaction-screen'),
            stanceSubmission: document.getElementById('stance-submission-screen'),
            complete: document.getElementById('complete-screen')
        };

        const elements = {
            problemList: document.getElementById('problem-list'),
            
            // Interaction Screen Components
            singleChatView: document.getElementById('single-chatbot-view'),
            singleChatWindow: document.getElementById('single-chat-window'),
            singleChatForm: document.getElementById('single-chat-form'),
            singleChatInput: document.getElementById('single-chat-input'),

            dualDebateView: document.getElementById('dual-debate-view'),
            startDebateBtn: document.getElementById('start-debate-btn'),
            debateWindow: document.getElementById('debate-window'),
            // NEW: Proceed button for debate
            debateProceedBtn: document.getElementById('debate-proceed-btn'),

            clarificationPanel: document.getElementById('clarification-panel'),
            clarificationChatWindow: document.getElementById('clarification-chat-window'),
            clarificationChatForm: document.getElementById('clarification-chat-form'),
            clarificationChatInput: document.getElementById('clarification-chat-input'),

            // Stance Screen
            stanceTopicTitle: document.getElementById('stance-topic-title'),
            stanceTextarea: document.getElementById('stance-textarea'),
        };

        // --- 5. CORE API FUNCTIONS ---

        /**
         * Original function to get a non-streamed response.
         * @param {string} systemPrompt - The system prompt
         * @param {Array} messageHistory - Message history
         * @param {number} maxTokens - Maximum tokens for response (optional)
         * @param {number} maxSentences - Maximum sentences to allow (optional, enforced after generation)
         */
        async function getFullAiResponse(systemPrompt, messageHistory, maxTokens = null, maxSentences = null) {
            if (!groq) {
                console.error("Groq not initialized.");
                throw new Error("AI connection not established.");
            }

            const messages = [
                { role: "system", content: systemPrompt },
                ...messageHistory
            ];

            const apiParams = {
                messages: messages,
                model: LLM_MODEL
            };

            // Add max_tokens if specified
            if (maxTokens) {
                apiParams.max_tokens = maxTokens;
            }

            const completion = await groq.chat.completions.create(apiParams);

            let response = completion.choices[0]?.message?.content || "No response.";

            // Apply sentence truncation if specified
            if (maxSentences) {
                response = truncateToSentences(response, maxSentences);
            }

            return response;
        }

        /**
         * NEW: Wrapper for getFullAiResponse that handles 429 rate limits with exponential backoff.
         * @param {string} systemPrompt - The system prompt
         * @param {Array} messageHistory - Message history
         * @param {number} maxTokens - Maximum tokens for response (optional)
         * @param {number} maxSentences - Maximum sentences to allow (optional)
         */
        async function getFullAiResponseWithBackoff(systemPrompt, messageHistory, maxTokens = null, maxSentences = null) {
            let retries = 0;
            let waitTime = 2000; // Initial wait time 2 seconds

            while (retries < MAX_RETRIES) {
                try {
                    // We only set isAiThinking right before the actual call
                    appState.isAiThinking = true;
                    const response = await getFullAiResponse(systemPrompt, messageHistory, maxTokens, maxSentences);
                    appState.isAiThinking = false;
                    return response; // Success
                } catch (error) {
                    appState.isAiThinking = false;
                    // Check if it's a Groq rate limit error
                    if (error.status === 429) {
                        retries++;
                        let delay = waitTime;
                        
                        // Try to parse the suggested wait time from the error message
                        try {
                            const errorBody = await error.response.json();
                            const message = errorBody.error.message;
                            const match = message.match(/Please try again in (\d+\.?\d*)s/);
                            if (match && match[1]) {
                                delay = parseFloat(match[1]) * 1000 + 200; // Use suggested time + 200ms buffer
                                console.warn(`Groq Rate Limit. Retrying in ${delay}ms...`);
                            } else {
                                console.warn(`Groq Rate Limit. Retrying in ${delay}ms... (default backoff)`);
                                waitTime *= 2; // Default exponential backoff
                            }
                        } catch (parseError) {
                            console.warn(`Groq Rate Limit. Retrying in ${delay}ms... (default backoff)`);
                            waitTime *= 2; // Default exponential backoff
                        }
                        
                        addMessageToWindow(`Rate limit hit. Waiting for ${Math.round(delay/1000)}s before retrying...`, 'system', elements.debateWindow);
                        await sleep(delay);
                    } else {
                        // Not a rate limit error, throw it
                        console.error("Groq API Error:", error);
                        return `Error connecting to AI: ${error.message}`;
                    }
                }
            }
            
            // If we exit the loop, we've exceeded max retries
            throw new Error(`Failed to get response from Groq after ${MAX_RETRIES} retries.`);
        }


        /**
         * UPDATED: Now accepts an `avatarClass` and a `thinkingMessageElement`
         * Generic function to stream an AI response to a chat window.
         * @param {number} maxTokens - Maximum tokens for response (optional)
         * @param {number} maxSentences - Maximum sentences to allow (optional, enforced after generation)
         */
        async function streamAiResponse(systemPrompt, messageHistory, targetWindow, speakerName, avatarClass = 'avatar-neutral', thinkingMessageElement, maxTokens = null, maxSentences = null) {
            if (!groq) {
                console.error("Groq not initialized.");
                addMessageToWindow("Error: AI connection not established.", "system", targetWindow);
                return;
            }
            if (appState.isAiThinking) return;
            appState.isAiThinking = true;

            // Use the provided 'thinking' element
            const msgElement = thinkingMessageElement;
            msgElement.className = `chat-message assistant ${avatarClass}`; // Add final classes
            msgElement.innerHTML = `<strong>${speakerName}</strong><span class="content"></span>`; // Set final structure
            const contentElement = msgElement.querySelector('.content');

            try {
                const messages = [
                    { role: "system", content: systemPrompt },
                    ...messageHistory
                ];

                const streamParams = {
                    messages: messages,
                    model: LLM_MODEL,
                    stream: true
                };

                // Add max_tokens if specified
                if (maxTokens) {
                    streamParams.max_tokens = maxTokens;
                }

                const stream = await groq.chat.completions.create(streamParams);

                let fullResponse = "";
                for await (const chunk of stream) {
                    const content = chunk.choices[0]?.delta?.content || "";
                    fullResponse += content;
                    contentElement.textContent = fullResponse; // Update text as it streams
                    targetWindow.scrollTop = targetWindow.scrollHeight;
                }

                // Apply sentence truncation if specified
                if (maxSentences) {
                    fullResponse = truncateToSentences(fullResponse, maxSentences);
                    contentElement.textContent = fullResponse; // Update with truncated version
                }

                return fullResponse; // Return the full response for history logging

            } catch (error) {
                console.error("Groq API Error:", error);
                contentElement.textContent = "Error connecting to AI. Please check the console.";
            } finally {
                appState.isAiThinking = false;
            }
        }

        // --- 6. UI AND STATE MANAGEMENT ---

        function showScreen(screenId) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            screens[screenId].classList.add('active');
            appState.currentScreen = screenId;
        }

        // Helper function to convert [source] citations to clickable links
        function convertSourceCitations(text, sourceUrls) {
            if (!sourceUrls || sourceUrls.length === 0) {
                return text;
            }

            let urlIndex = 0;

            // Replace each [source] with a clickable link, cycling through available URLs
            return text.replace(/\[source\]/gi, (match) => {
                if (urlIndex < sourceUrls.length) {
                    const url = sourceUrls[urlIndex];
                    urlIndex++;
                    return `<a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary-color); text-decoration: underline; font-weight: 500;" title="View source">[source]</a>`;
                }
                return match; // Return unchanged if we've run out of URLs
            });
        }

        function addMessageToWindow(text, sender, targetWindow, speakerName = null) {
            const msg = document.createElement('div');
            msg.className = `chat-message ${sender}`; // sender is 'user' or 'assistant' or 'system' or 'assistant agent-a'

            let html = "";
            if (speakerName) {
                html += `<strong>${speakerName}</strong>`;
            }

            // Convert [source] citations to clickable links
            const processedText = convertSourceCitations(text, appState.currentSourceUrls);
            html += processedText;

            msg.innerHTML = html;

            targetWindow.appendChild(msg);
            targetWindow.scrollTop = targetWindow.scrollHeight;
            return msg; // Return the element
        }

        function populateProblemList() {
            elements.problemList.innerHTML = "";
            for (const [id, problem] of Object.entries(PROBLEMS)) {
                const btn = document.createElement('button');
                btn.textContent = problem.title;
                btn.onclick = () => app.selectProblem(id);
                elements.problemList.appendChild(btn);
            }
        }
        
        function setupInteractionScreen() {
            const problem = appState.selectedProblem;
            if (!problem) return;

            // Reset views
            elements.singleChatView.style.display = 'none';
            elements.dualDebateView.style.display = 'none';
            elements.clarificationPanel.style.display = 'none';

            if (appState.interactionMode === 'singleChatbot') {
                elements.singleChatView.style.display = 'flex';
                // Add problem context to chat
                addMessageToWindow(`<strong>${problem.title}</strong>`, 'system', elements.singleChatWindow);
                appState.singleChatHistory.push({ role: 'system', content: `The selected topic is: ${problem.fullText}` });

            } else if (appState.interactionMode === 'dualDebate') {
                elements.dualDebateView.style.display = 'flex';
                elements.clarificationPanel.style.display = 'flex';
                // Add problem context to clarification chat
                addMessageToWindow(`<strong>${problem.title}</strong>`, 'system', elements.clarificationChatWindow);
                appState.clarificationChatHistory.push({ role: 'system', content: `The selected topic is: ${problem.fullText}` });
                // Add context to debate window
                addMessageToWindow(`<strong>${problem.title}</strong>`, 'system', elements.debateWindow);
            }
        }

        // --- 7. APPLICATION LOGIC FLOW (Public Methods) ---

        const app = {
            startSession(mode) {
                console.log(`Starting session for ${mode}`);
                appState.interactionMode = mode;
                populateProblemList();
                showScreen('problemSelection');
            },

            selectProblem(problemId) {
                console.log(`Problem selected: ${problemId}`);
                appState.selectedProblemId = problemId;
                appState.selectedProblem = PROBLEMS[problemId];
                setupInteractionScreen();
                showScreen('interaction');
            },
            
            async handleSingleChatSubmit(event) {
                event.preventDefault();
                const input = elements.singleChatInput;
                const userInput = input.value.trim();
                if (!userInput || appState.isAiThinking) return;
                
                // Add user message to UI and history
                addMessageToWindow(userInput, 'user', elements.singleChatWindow, "You");
                appState.singleChatHistory.push({ role: 'user', content: userInput });
                input.value = "";
                
                // NEW: Add "Thinking..." message and pass it to the stream function
                const thinkingMsg = addMessageToWindow(
                    "Thinking", 
                    "assistant avatar-neutral thinking", 
                    elements.singleChatWindow, 
                    PERSONAS.clarification.name
                );

                // Get AI response with limits
                const aiResponse = await streamAiResponse(
                    PERSONAS.clarification.systemPrompt,
                    appState.singleChatHistory,
                    elements.singleChatWindow,
                    PERSONAS.clarification.name,
                    'avatar-neutral',
                    thinkingMsg,  // Pass the element to be filled
                    PERSONAS.clarification.maxTokens,     // Apply token limit
                    PERSONAS.clarification.maxSentences   // Apply sentence limit
                );

                // Add AI response to history
                if (aiResponse) {
                    appState.singleChatHistory.push({ role: 'assistant', content: aiResponse });
                }
            },
            
            async handleClarificationChatSubmit(event) {
                event.preventDefault();
                const input = elements.clarificationChatInput;
                const userInput = input.value.trim();
                if (!userInput || appState.isAiThinking) return;
                
                // Add user message to UI and history
                addMessageToWindow(userInput, 'user', elements.clarificationChatWindow, "You");
                appState.clarificationChatHistory.push({ role: 'user', content: userInput });
                input.value = "";
                
                // NEW: Add "Thinking..." message and pass it to the stream function
                const thinkingMsg = addMessageToWindow(
                    "Thinking", 
                    "assistant avatar-neutral thinking", 
                    elements.clarificationChatWindow, 
                    PERSONAS.clarification.name
                );
                
                // Get AI response with limits
                const aiResponse = await streamAiResponse(
                    PERSONAS.clarification.systemPrompt,
                    appState.clarificationChatHistory,
                    elements.clarificationChatWindow,
                    PERSONAS.clarification.name,
                    'avatar-neutral',
                    thinkingMsg,  // Pass the element to be filled
                    PERSONAS.clarification.maxTokens,     // Apply token limit
                    PERSONAS.clarification.maxSentences   // Apply sentence limit
                );

                // Add AI response to history
                if (aiResponse) {
                    appState.clarificationChatHistory.push({ role: 'assistant', content: aiResponse });
                }
            },

            async runDebate() {
                console.log("Running debate...");
                elements.startDebateBtn.disabled = true;
                elements.startDebateBtn.innerHTML = '<span class="spinner"></span> Debate in Progress...';

                const problemText = appState.selectedProblem.fullText;

                appState.debateHistory = [];

                try {
                    // Search for current information about the topic
                    const searchQuery = `${appState.selectedProblem.title} latest statistics facts 2024 2025`;
                    const searchResults = await searchTavily(searchQuery);

                    let searchContext = "";
                    if (searchResults && searchResults.answer) {
                        searchContext = `\n\nCurrent information: ${searchResults.answer}`;
                        if (searchResults.results && searchResults.results.length > 0) {
                            // Store URLs in appState for citation conversion
                            appState.currentSourceUrls = searchResults.results.slice(0, 3).map(r => r.url);
                            searchContext += `\n\n(Sources are available - cite claims by writing [source])`;
                        }
                    }

                    // First, provide a brief topic introduction
                    const introPrompt = [
                        { role: 'user', content: `Provide a brief 1-2 sentence introduction explaining what this topic is about: ${problemText}${searchContext}` }
                    ];
                    const topicIntro = await getFullAiResponseWithBackoff(
                        "You are a neutral educator providing clear, unbiased context. You MUST explain the topic in EXACTLY 1-2 short sentences (under 30 words total). DO NOT exceed 2 sentences.",
                        introPrompt,
                        TOKEN_LIMITS.topicIntro,  // Token limit
                        2  // Max 2 sentences
                    );
                    addMessageToWindow(topicIntro, 'topic-intro', elements.debateWindow);
                    await sleep(1500); // Brief pause after introduction

                    // Separate message histories for each agent
                    let agentForHistory = [
                        { role: 'user', content: `The topic to be debated is: ${problemText}.${searchContext}\n\nYour position: Argue FOR this topic. Present your opening statement with evidence-based arguments supporting this position. Use current data and facts.` }
                    ];

                    let agentAgainstHistory = [
                        { role: 'user', content: `The topic to be debated is: ${problemText}.${searchContext}\n\nYour position: Argue AGAINST this topic. Present your opening statement with evidence-based arguments opposing this position. Use current data and facts.` }
                    ];

                    for (let i = 0; i < DEBATE_EXCHANGES * 2; i++) {
                        const isAgentFor = i % 2 === 0;
                        const agent = isAgentFor ? PERSONAS.agentFor : PERSONAS.agentAgainst;
                        const agentClass = isAgentFor ? 'agent-for' : 'agent-against';
                        const agentHistory = isAgentFor ? agentForHistory : agentAgainstHistory;
                        const opponentHistory = isAgentFor ? agentAgainstHistory : agentForHistory;

                        // Get agent response with strict limits
                        const aiResponse = await getFullAiResponseWithBackoff(
                            agent.systemPrompt,
                            agentHistory,
                            agent.maxTokens,      // Apply token limit from persona
                            agent.maxSentences    // Apply sentence limit from persona
                        );
                        addMessageToWindow(aiResponse, `assistant ${agentClass}`, elements.debateWindow, agent.name);

                        appState.debateHistory.push({ speaker: agent.name, text: aiResponse });

                        // Add the response to this agent's history
                        agentHistory.push({ role: 'assistant', content: aiResponse });

                        // Add the response to the opponent's history as context
                        opponentHistory.push({ role: 'user', content: `Your opponent just argued: "${aiResponse}"\n\nRespond to this argument from your assigned position with evidence.` });

                        // Add fact-checking after every exchange pair
                        if (i % 2 === 1 && i < DEBATE_EXCHANGES * 2 - 1) {
                            await sleep(EXCHANGE_DELAY);

                            // Search for verification of claims
                            const factSearchQuery = `verify fact check: ${aiResponse.substring(0, 200)}`;
                            const factSearchResults = await searchTavily(factSearchQuery);

                            let factContext = "";
                            if (factSearchResults && factSearchResults.answer) {
                                factContext = `\n\nWeb verification: ${factSearchResults.answer}`;
                            }

                            const factCheckPrompt = [
                                { role: 'user', content: `Review this argument: "${aiResponse}".${factContext}\n\nFact-check one key claim using the verification data provided.` }
                            ];
                            const factCheck = await getFullAiResponseWithBackoff(
                                PERSONAS.factChecker.systemPrompt,
                                factCheckPrompt,
                                PERSONAS.factChecker.maxTokens,
                                PERSONAS.factChecker.maxSentences
                            );
                            addMessageToWindow(factCheck, 'assistant fact-checker', elements.debateWindow, PERSONAS.factChecker.name);
                        }

                        await sleep(EXCHANGE_DELAY);
                    }

                    // Final fact check after all exchanges
                    await sleep(EXCHANGE_DELAY);

                    // Search for overall topic verification
                    const finalSearchQuery = `${appState.selectedProblem.title} latest facts statistics 2024 2025`;
                    const finalSearchResults = await searchTavily(finalSearchQuery);

                    let finalFactContext = "";
                    if (finalSearchResults && finalSearchResults.answer) {
                        finalFactContext = `\n\nLatest information: ${finalSearchResults.answer}`;
                    }

                    const finalFactCheckPrompt = [
                        { role: 'user', content: `Review the overall debate and fact-check one key claim from either side.${finalFactContext}` }
                    ];
                    const finalFactCheck = await getFullAiResponseWithBackoff(
                        PERSONAS.factChecker.systemPrompt,
                        finalFactCheckPrompt,
                        PERSONAS.factChecker.maxTokens,
                        PERSONAS.factChecker.maxSentences
                    );
                    addMessageToWindow(finalFactCheck, 'assistant fact-checker', elements.debateWindow, PERSONAS.factChecker.name);

                    addMessageToWindow("Debate complete.", 'system', elements.debateWindow);

                    // Generate TLDR
                    const tldrPrompt = [
                        { role: 'user', content: `Summarize this debate in exactly 3 short sentences:\n${appState.debateHistory.map(h => `${h.speaker}: ${h.text}`).join('\n\n')}` }
                    ];
                    const tldr = await getFullAiResponseWithBackoff(
                        PERSONAS.summarizer.systemPrompt,
                        tldrPrompt,
                        PERSONAS.summarizer.maxTokens,
                        PERSONAS.summarizer.maxSentences
                    );

                    // Display TLDR as clean bullet points with FOR/AGAINST/CONCLUSION structure
                    const tldrContainer = document.getElementById('tldr-container');

                    // Parse the summary to extract FOR/AGAINST/CONCLUSION
                    const lines = tldr.split('\n').map(line => line.trim()).filter(line => line.length > 0);

                    let forPoint = '';
                    let againstPoint = '';
                    let conclusionPoint = '';

                    lines.forEach(line => {
                        if (line.match(/^FOR:/i)) {
                            forPoint = line.replace(/^FOR:\s*/i, '');
                        } else if (line.match(/^AGAINST:/i)) {
                            againstPoint = line.replace(/^AGAINST:\s*/i, '');
                        } else if (line.match(/^CONCLUSION:/i)) {
                            conclusionPoint = line.replace(/^CONCLUSION:\s*/i, '');
                        }
                    });

                    const tldrHTML = `<div class="tldr-section">
                        <h3>Summary</h3>
                        <ul>
                            <li><strong>FOR:</strong> ${forPoint || 'Supporting arguments were presented.'}</li>
                            <li><strong>AGAINST:</strong> ${againstPoint || 'Opposing concerns were raised.'}</li>
                            <li><strong>CONCLUSION:</strong> ${conclusionPoint || 'Key tensions remain between these positions.'}</li>
                        </ul>
                    </div>`;
                    tldrContainer.innerHTML = tldrHTML;

                    elements.startDebateBtn.textContent = "Debate Complete";
                    elements.debateProceedBtn.disabled = false;
                    elements.debateProceedBtn.textContent = "Proceed to Submit Stance";

                } catch (error) {
                    console.error("Debate failed:", error);
                    addMessageToWindow(`Error: ${error.message}`, 'system', elements.debateWindow);
                    elements.startDebateBtn.textContent = "Debate Failed";
                    elements.startDebateBtn.style.backgroundColor = 'red';
                }
            },
            
            // Function to move to the stance screen
            goToStanceScreen() {
                console.log("Proceeding to stance submission.");
                elements.stanceTopicTitle.textContent = appState.selectedProblem.title;
                showScreen('stanceSubmission');
            },

            // Back button navigation
            goBack() {
                const currentScreen = appState.currentScreen;
                if (currentScreen === 'problemSelection') {
                    showScreen('welcome');
                } else if (currentScreen === 'interaction') {
                    showScreen('problemSelection');
                } else if (currentScreen === 'stanceSubmission') {
                    showScreen('interaction');
                }
            },

            // Custom topic selection
            selectCustomTopic() {
                const title = document.getElementById('custom-topic-title').value.trim();
                const description = document.getElementById('custom-topic-description').value.trim();

                if (!title || !description) {
                    alert('Please provide both a title and description for your custom topic.');
                    return;
                }

                // Create a custom problem object
                const customId = 'custom-' + Date.now();
                PROBLEMS[customId] = {
                    title: title,
                    fullText: description
                };

                app.selectProblem(customId);
            },

            async submitStance(event) {
                event.preventDefault(); // Prevent default form submission
                const stance = elements.stanceTextarea.value.trim();
                if (!stance) {
                    elements.stanceTextarea.style.borderColor = 'red';
                    elements.stanceTextarea.placeholder = "Please enter your stance before submitting.";
                    return;
                }

                elements.stanceTextarea.style.borderColor = 'var(--border-color)';
                appState.userStance = stance;

                const finalData = {
                    participantId: appState.participantId,
                    interactionMode: appState.interactionMode,
                    problemId: appState.selectedProblemId,
                    problemTitle: appState.selectedProblem.title,
                    userStance: appState.userStance,
                    logs: {
                        singleChatHistory: appState.singleChatHistory,
                        clarificationChatHistory: appState.clarificationChatHistory,
                        debateHistory: appState.debateHistory
                    }
                };

                // Populate the hidden input with the JSON data
                document.getElementById('submission-data-input').value = JSON.stringify(finalData, null, 2);

                const formData = new FormData(event.target);
                fetch("/", {
                    method: "POST",
                    headers: { "Content-Type": "application/x-www-form-urlencoded" },
                    body: new URLSearchParams(formData).toString()
                }).then(() => showScreen('complete')).catch((error) => alert(error));

            }
        };
        
        // --- 8. INITIALIZATION ---

        function init() {
            // Initialize Groq SDK
            if (API_KEY && !API_KEY.includes("YOUR_")) {
                try {
                    groq = new Groq({ apiKey: API_KEY, dangerouslyAllowBrowser: true });
                    console.log("Groq SDK Initialized.");
                } catch(e) { 
                    console.error("Failed to initialize Groq SDK:", e); 
                    // Use a non-blocking error display
                    const header = document.querySelector('header h1');
                    if (header) {
                        header.textContent = "Error: AI Connection Failed. Check Console.";
                        header.style.color = "#ffcccc";
                    }
                }
            } else {
                console.warn("API Key missing. AI features will be offline.");
                const header = document.querySelector('header h1');
                if (header) {
                    header.textContent = "CRITICAL: Groq API Key is missing. App offline.";
                    header.style.color = "#ffcccc";
                }
            }

            elements.stanceForm = document.getElementById('stance-form');

            // --- Add Event Listeners ---
            elements.singleChatForm.addEventListener('submit', app.handleSingleChatSubmit);
            elements.clarificationChatForm.addEventListener('submit', app.handleClarificationChatSubmit);
            elements.stanceForm.addEventListener('submit', app.submitStance);
            
            // Make app object globally accessible for HTML onclick attributes
            window.app = app;
            
            console.log("Application Initialized.");
        }

        init();
    </script>
</body>
</html>


